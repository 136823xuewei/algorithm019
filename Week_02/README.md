学习笔记  
第二周 第五课 哈希表、映射、集合  
 1、实现与特性  
哈希表，也叫做散列表，是根据关键码值而直接进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做哈希表。  
避免哈希碰撞，出现哈希碰撞的话，则在相应位置用链表来实现  
正常情况下：查询、添加和删除元素的时间复杂度是o(1)  
python中经常使用dict()、set()  
java中set的实现有很多底层结构
 2、hashmap小总结  
 hashmap实际上是一个数组，每个元素是一个链表，每一个node是一个元素，元素包括key和value。put之前，先计算key值的hashcode，此值为数据在数组中的索引。 获取插入数据的位置，这个位置为空的时候，被分配一个空位置；不为空的时候，说明map里面已经有这个元素，返回之前的位置。 
 get的时候，计算key的hashcode，从数组中取出数，因此get的速度很快，时间复杂度为o(1)。hashcode相同的值被放在一个链表中，查找的时候就循环这个链表进行查找。  

第二周 第6课 树、二叉树、二叉搜索树  
提升速度的思想：升维  
二维数据结构：树  
linked list是特殊化的tree,tree是特殊化的graph：tree的节点有多于一个的next指针，且内部没有环  
思考：树的面试题解法一般都是递归？  
一维数据结构可以进行有规律的循环，且实现简单；树没法进行有效的循环，循环实现复杂，除此之外，树本身的定义决定了它用递归实现起来更简单。
树的遍历方式：前序（根左右）、中序（左根右）、后序（左右根）  
熟练python中树的三种遍历方式模板  
二叉搜索树的中序遍历是升序遍历  

第二周 第7课 堆、二叉堆、图  
堆heap:可以迅速找到一堆数中的最大或者最小值的数据结构。是一种抽象的数据结构，优先队列就是堆。  
将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆。  
常见的堆有二叉堆、斐波那契堆等  
假设是大顶堆，则常见的操作：  
find-max: O(1)  
delete-max:O(logN)  
insert(creat):O(logN) or O(1)  
二叉堆的性质：通过完全二叉树来实现（注意：不是二叉搜索树）  
二叉堆（大顶）满足下列性质：是一棵完全树；树中任意节点的值总是>=其子节点的值  
二叉堆实现细节：  
1、一般都通过一维数组来实现，也可以通过二叉树实现。  
2、假设第一个元素在数组中的索引为0，则父节点和子节点的位置关系如下：  
索引为i的左孩子的索引是（2*i+1）  
索引为i的右孩子的索引是（2*i+2）
索引为i的父节点的索引是floor((i-1)/2)  
insert:heapifyup  
delete:heapifydown
分析heapsort:  
heapsort是基于二叉堆数据结构的一种排序方法。排序方式是升序。  
步骤：1、对输入数据建立一个大顶堆。  
2、将最大值放在堆的根节点中，遍历堆中的数据进行替换。
python实现堆排序：用数组构建  
队列实现广度优先搜索、栈实现深度优先搜索  
图可以用邻接矩阵和邻接表来表示，无向无权图的邻接矩阵是对称矩阵。  
有向无权图、无向有权图、有向有权图。   
基于图的常见算法：Dfs\Bfs 的递归算法，相比于树中的最大区别，实现中必须加上visited = set()  
熟练掌握图中Dfs\Bfs的模版。